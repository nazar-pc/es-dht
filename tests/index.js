// Generated by LiveScript 1.5.0
/**
 * @package Entangled state DHT
 * @author  Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @license 0BSD
 */
(function(){
  var arrayMapSet, crypto, lib, test, ArrayMap, sha1, random_bytes, instances;
  arrayMapSet = require('array-map-set');
  crypto = require('crypto');
  lib = require('..');
  test = require('tape');
  ArrayMap = arrayMapSet.ArrayMap;
  sha1 = function(data){
    return crypto.createHash('sha1').update(data).digest();
  };
  random_bytes = crypto.randomBytes;
  instances = ArrayMap();
  function Simple_DHT(id, bootstrap_node_id){
    var state, state_version, proof, peers;
    bootstrap_node_id == null && (bootstrap_node_id = null);
    if (!(this instanceof Simple_DHT)) {
      return new Simple_DHT(id, bootstrap_node_id);
    }
    this._id = id;
    instances.set(id, this);
    this._dht = lib(id, sha1, 20, 1000);
    this._data = ArrayMap();
    if (bootstrap_node_id) {
      state = this._request(bootstrap_node_id, 'bootstrap', this._dht.get_state());
      if (state) {
        state_version = state[0], proof = state[1], peers = state[2];
        this._dht.set_peer(bootstrap_node_id, state_version, proof, peers);
      }
    }
  }
  Simple_DHT.prototype = {
    lookup: function(id){
      this._handle_lookup(this._dht.start_lookup(id));
      return this._dht.finish_lookup(id);
    },
    _handle_lookup: function(nodes_to_connect_to){
      var i$, len$, ref$, target_node_id, parent_node_id, parent_state_version, proof, target_node_state_version, target_node_peers;
      if (!nodes_to_connect_to.length) {
        return;
      }
      for (i$ = 0, len$ = nodes_to_connect_to.length; i$ < len$; ++i$) {
        ref$ = nodes_to_connect_to[i$], target_node_id = ref$[0], parent_node_id = ref$[1], parent_state_version = ref$[2];
        proof = this._request(parent_node_id, 'get_state_proof', [target_node_id, parent_state_version]);
        target_node_state_version = this._dht.check_state_proof(parent_state_version, parent_node_id, proof, target_node_id);
        if (target_node_state_version) {
          ref$ = this._request(target_node_id, 'get_state', target_node_state_version), proof = ref$[0], target_node_peers = ref$[1];
          if (this._dht.check_state_proof(target_node_state_version, target_node_id, proof, target_node_id)) {
            this._handle_lookup(this._dht.update_lookup(id, target_node_id, target_node_state_version, target_node_peers));
          }
        }
      }
    },
    put: function(data){
      var infohash, i$, ref$, len$, node;
      infohash = sha1(data);
      this._data.set(infohash, data);
      for (i$ = 0, len$ = (ref$ = this.lookup(infohash)).length; i$ < len$; ++i$) {
        node = ref$[i$];
        this._request(node, 'put', data);
      }
      return infohash;
    },
    get: function(infohash){
      var i$, ref$, len$, node, data;
      if (this._data.has(infohash)) {
        return this._data.get(infohash);
      } else {
        for (i$ = 0, len$ = (ref$ = this.lookup(infohash)).length; i$ < len$; ++i$) {
          node = ref$[i$];
          data = this._request(node, 'get', infohash);
          if (data) {
            return data;
          }
        }
        return null;
      }
    },
    destroy: function(){
      clearInterval(this._interval);
    },
    _request: function(target_id, command, data){
      return instances.get(target_id)._response(this._id, command, data);
    },
    _response: function(source_id, command, data){
      var state_version, proof, peers, infohash, peer_id;
      switch (command) {
      case 'bootstrap':
        state_version = data[0], proof = data[1], peers = data[2];
        return this._dht.set_peer(source_id, state_version, proof, peers) ? this._dht.get_state() : null;
      case 'get':
        return this._data.get(data) || null;
      case 'put':
        infohash = sha1(data);
        this._data.set(infohash, data);
        break;
      case 'get_state_proof':
        peer_id = data[0], state_version = data[1];
        return this._dht.get_state_proof(peer_id, state_version);
      case 'get_state':
        return this._dht.get_state(data).slice(1);
      case 'put_state':
        state_version = data[0], proof = data[1], peers = data[2];
        this._dht.set_peer(source_id, state_version, proof, peers);
      }
    }
  };
  test('es-dht', function(t){
    var nodes, bootstrap_node_id, i$, _, id, node_0, node_5, node_20, data, infohash;
    t.plan(4);
    console.log('Creating instances...');
    nodes = [];
    bootstrap_node_id = random_bytes(20);
    Simple_DHT(bootstrap_node_id);
    for (i$ = 0; i$ < 100; ++i$) {
      _ = i$;
      id = random_bytes(20);
      nodes.push(id);
      Simple_DHT(id, bootstrap_node_id);
    }
    console.log('Warm-up...');
    node_0 = instances.get(nodes[0]);
    node_5 = instances.get(nodes[5]);
    node_20 = instances.get(nodes[20]);
    data = random_bytes(10);
    infohash = node_0.put(data);
    t.ok(infohash, 'put succeeded');
    t.equal(node_0.get(infohash), data, 'get on node 0 succeeded');
    t.equal(node_5.get(infohash), data, 'get on node 5 succeeded');
    t.equal(node_20.get(infohash), data, 'get on node 20 succeeded');
    instances.forEach(function(instance){
      instance.destroy();
    });
  });
}).call(this);
